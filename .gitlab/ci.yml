# NOTE: This file is auto generated by OpenAPI Generator.
# URL: [https://openapi-generator.tech](https://openapi-generator.tech)
#
# ref: [https://docs.gitlab.com/ee/ci/README.html](https://docs.gitlab.com/ee/ci/README.html)

stages:
  - sast
  - test
  - build
  - publish
  - integration
  - sync

include:
  - template: Security/SAST.gitlab-ci.yml

semgrep-sast:
  stage: sast
  extends: .sast-analyzer

# Common config for all SAST analyzers
.sast-analyzer:
  tags:
    - aliyun-sit-runner
  artifacts:
    reports:
      sast: gl-sast-report.json
    paths:
      - gl-sast-report.json
      - reports/
    expire_in: 1 week
    when: always
  rules:
    - if: '$CI_PIPELINE_SOURCE == "schedule"'
      when: never
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      when: always
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: always
  after_script:
    - apk add --no-cache jq
    - |
      # Detailed SAST report summary
      if [ -f gl-sast-report.json ]; then
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo "                               SAST SECURITY REPORT                              "
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        
        # Scanner information
        echo "\n📊 SCAN DETAILS"
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo "Scanner: $(jq -r '.scan.scanner.name' gl-sast-report.json) v$(jq -r '.scan.scanner.version' gl-sast-report.json)"
        echo "Started: $(jq -r '.scan.start_time' gl-sast-report.json)"
        echo "Completed: $(jq -r '.scan.end_time' gl-sast-report.json)"
        echo "Status: $(jq -r '.scan.status' gl-sast-report.json)"
        
        # Issue summary
        TOTAL=$(jq '.vulnerabilities | length' gl-sast-report.json)
        CRITICAL=$(jq '.vulnerabilities | map(select(.severity == "Critical")) | length' gl-sast-report.json)
        HIGH=$(jq '.vulnerabilities | map(select(.severity == "High")) | length' gl-sast-report.json)
        MEDIUM=$(jq '.vulnerabilities | map(select(.severity == "Medium")) | length' gl-sast-report.json)
        LOW=$(jq '.vulnerabilities | map(select(.severity == "Low")) | length' gl-sast-report.json)
        INFO=$(jq '.vulnerabilities | map(select(.severity == "Info")) | length' gl-sast-report.json)
        
        echo "\n🔍 FINDINGS SUMMARY"
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo "Total issues: $TOTAL"
        echo "  - Critical: $CRITICAL"
        echo "  - High:     $HIGH"
        echo "  - Medium:   $MEDIUM"
        echo "  - Low:      $LOW"
        echo "  - Info:     $INFO"
        
        # Most affected files
        echo "\n📁 MOST AFFECTED FILES"
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        jq -r '.vulnerabilities | group_by(.location.file) | map({file: .[0].location.file, count: length}) | sort_by(.count) | reverse | .[0:5] | .[] | "  - \(.file): \(.count) issues"' gl-sast-report.json
        
        # Most common issue types
        echo "\n⚠️ MOST COMMON ISSUE TYPES"
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        jq -r '.vulnerabilities | group_by(.message) | map({message: .[0].message, count: length}) | sort_by(.count) | reverse | .[0:5] | .[] | "  - \(.message): \(.count) occurrences"' gl-sast-report.json
        
        # Process and display each vulnerability separately to avoid YAML parsing issues
        echo "\n🛡️ DETAILED FINDINGS"
        
        # Extract total number of vulnerabilities
        VULN_COUNT=$(jq '.vulnerabilities | length' gl-sast-report.json)
        
        # Loop through each vulnerability
        for i in $(seq 0 $(($VULN_COUNT - 1))); do
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          
          # Extract details for this vulnerability
          TYPE=$(jq -r ".vulnerabilities[$i].category" gl-sast-report.json)
          NAME=$(jq -r ".vulnerabilities[$i].name" gl-sast-report.json)
          MESSAGE=$(jq -r ".vulnerabilities[$i].message" gl-sast-report.json)
          SEVERITY=$(jq -r ".vulnerabilities[$i].severity" gl-sast-report.json)
          FILE=$(jq -r ".vulnerabilities[$i].location.file" gl-sast-report.json)
          DESCRIPTION=$(jq -r ".vulnerabilities[$i].description" gl-sast-report.json)
          SCANNER=$(jq -r ".vulnerabilities[$i].scanner.name" gl-sast-report.json)
          START_LINE=$(jq -r ".vulnerabilities[$i].location.start_line" gl-sast-report.json)
          END_LINE=$(jq -r ".vulnerabilities[$i].location.end_line" gl-sast-report.json)
          
          # Format output
          echo "• Issue #$((i+1)): $NAME"
          echo "• Severity: $SEVERITY"
          echo "• Type: $TYPE"
          echo "• Message: $MESSAGE"
          echo "• File: $FILE"
          
          if [ "$START_LINE" = "$END_LINE" ] || [ -z "$END_LINE" ]; then
            echo "• Line: $START_LINE"
          else
            echo "• Lines: $START_LINE-$END_LINE"
          fi
          
          echo "• Description: $DESCRIPTION"
          echo "• Scanner: $SCANNER"
          echo "\n• Identifiers:"
          
          # Extract number of identifiers
          ID_COUNT=$(jq -r ".vulnerabilities[$i].identifiers | length" gl-sast-report.json)
          
          # Loop through each identifier
          for j in $(seq 0 $(($ID_COUNT - 1))); do
            ID_TYPE=$(jq -r ".vulnerabilities[$i].identifiers[$j].type" gl-sast-report.json)
            ID_NAME=$(jq -r ".vulnerabilities[$i].identifiers[$j].name" gl-sast-report.json)
            ID_VALUE=$(jq -r ".vulnerabilities[$i].identifiers[$j].value" gl-sast-report.json)
            ID_URL=$(jq -r ".vulnerabilities[$i].identifiers[$j].url" gl-sast-report.json)
            
            echo "    - $ID_TYPE: $ID_NAME ($ID_VALUE)"
            echo "      URL: $ID_URL"
          done
          
          echo ""
        done
        
        echo "\n🔒 SAST SCAN COMPLETE. See GitLab Security Dashboard for more details."
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
      else
        echo "No SAST report found (gl-sast-report.json does not exist)"
      fi
  variables:
    SAST_EXCLUDED_PATHS: "spec, test, tests, tmp"
    SCAN_KUBERNETES_MANIFESTS: "false"
    SAST_ANALYZER_IMAGE_TAG: "3"
    SAST_DISABLE_DIND: "true"
    REPORT_FORMAT: "json"
    SAST_EXCLUDED_ANALYZERS: ""



.go-test:
  stage: test
  tags: 
    - aliyun-sit-runner
  before_script:
    - apk add --no-cache gcc musl-dev git
    - echo "Adding replace directive to go.mod for local testing"
    - echo "replace github.com/dana-id/dana-go => ../" >> go.mod
    - cat go.mod
  script:
    - go version
    - go mod tidy
    - go test ./test -v
  after_script:
    - echo "Removing replace directive from go.mod"
    - sed -i '/replace github.com\/dana-id\/dana-go =>/d' go.mod
  rules:
    - if: '$CI_PIPELINE_SOURCE == "schedule"'
      when: never
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH == "main"'

go-test-1.19:
  extends: .go-test
  image: golang:1.19-alpine
go-test-1.20:
  extends: .go-test
  image: golang:1.20-alpine
go-test-1.21:
  extends: .go-test
  image: golang:1.21-alpine
go-test-1.22:
  extends: .go-test
  image: golang:1.22-alpine

integration-test:
  stage: integration
  image: golang:1.22-alpine
  tags: 
    - aliyun-sit-runner
  variables:
    PRIVATE_KEY: $PRIVATE_KEY
    X_PARTNER_ID: $X_PARTNER_ID
    ORIGIN: $ORIGIN
    CHANNEL_ID: $CHANNEL_ID
    MERCHANT_ID: $MERCHANT_ID
  script:
    # Install necessary packages
    - apk add --no-cache git sed jq
    
    # Setup GOPRIVATE and git for accessing private repositories
    - go env -w GOPRIVATE=gitlab.dana.id
    - git config --global url."https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.dana.id/".insteadOf "https://gitlab.dana.id/"
    
    # Create .netrc file for GitLab authentication
    - |
      cat > ~/.netrc << EOF
      machine gitlab.dana.id
      login gitlab-ci-token
      password ${CI_JOB_TOKEN}
      EOF
      chmod 600 ~/.netrc
    
    # Create a temporary workspace
    - mkdir -p /tmp/dana-go-test
    - cd /tmp/dana-go-test
    
    # Clone the current RC package repository
    - |
      if [[ -n "$CI_COMMIT_TAG" ]]; then
        echo "Cloning current repository at tag: $CI_COMMIT_TAG"
        git clone https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.dana.id/automation/dana-go-api-client.git
        cd dana-go-api-client
        git checkout $CI_COMMIT_TAG
      else
        echo "ERROR: No tag specified. Integration tests must run with a specific tag."
        exit 1
      fi
    
    # Clone the integration test repository
    - cd /tmp/dana-go-test
    - git clone https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.dana.id/automation/dana-self-integration-test.git
    - cd dana-self-integration-test
    
    # Modify test/go/go.mod to use local package
    - |
      if [[ -n "$CI_COMMIT_TAG" ]]; then
        echo "Setting up local package in go.mod"
        
        # Remove any existing replace directive
        sed -i '/replace github.com\/dana-id\/dana-go =>/d' test/go/go.mod
        
        # Add replace directive to use local package
        echo "replace github.com/dana-id/dana-go => /tmp/dana-go-test/dana-go-api-client" >> test/go/go.mod
        
        echo "Updated go.mod with local package replace directive:"
        cat test/go/go.mod
        
        # Modify run-test.sh to avoid downloading packages
        echo "Removing go get commands from run-test.sh"
        sed -i 's|go get -u github.com/dana-id/dana-go|# Using local package instead|g' run-test.sh
        
        echo "Modified run-test.sh:"
        grep -n "go get" run-test.sh || echo "No go get commands found in run-test.sh"
      else
        echo "Warning: No version tag found, using latest version"
      fi
    
    # Create .env file for testing
    - echo "Creating .env file from CI variables..."
    - |
      cat > .env << EOF
      MERCHANT_ID=${MERCHANT_ID}
      X_PARTNER_ID=${X_PARTNER_ID}
      CHANNEL_ID=${CHANNEL_ID}
      PRIVATE_KEY='${PRIVATE_KEY}'
      ORIGIN=${ORIGIN}
      EOF
    - echo "Created .env file"
    
    # Run the tests
    - echo "Running integration tests with local package..."
    - sh run-test.sh go
  rules:
    - if: '$CI_COMMIT_TAG =~ /^v\d+\.\d+\.\d+-rc\.\d+$/'
      when: always

verify-rc-integration:
  stage: test
  image: alpine:latest
  tags:
    - aliyun-sit-runner
  script:
    # Install required tools
    - 'apk add --no-cache curl jq python3 git'
    # Extract version from tag
    - 'VERSION=${CI_COMMIT_TAG#v}'
    - 'echo "Looking for RC tags for version $VERSION"'
    # Download verification script from central repository
    - 'mkdir -p temp_scripts'
    - 'git clone --depth 1 https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.dana.id/automation/dana-api-client-generator.git temp_scripts/repo'
    - 'cp temp_scripts/repo/scripts/ci/verify_rc_integration.py temp_scripts/'
    - 'chmod +x temp_scripts/verify_rc_integration.py'
    # Run the verification script
    - 'LATEST_RC=$(python3 temp_scripts/verify_rc_integration.py "$VERSION")'
    - 'EXIT_CODE=$?'
    - 'if [ $EXIT_CODE -ne 0 ]; then echo "Failed to find RC tag with passing integration tests"; exit 1; fi'
    - 'echo "Verified RC tag for release: $LATEST_RC"'
  rules:
    - if: '$CI_COMMIT_TAG =~ /^v\d+\.\d+\.\d+$/'
      when: always

# Define build and publish stages similar to Python client
# Build jobs removed as they are not needed for Go
# The Go code is directly used from the GitLab/GitHub repos

publish-to-github:
  stage: sync
  image: golang:1.22-alpine
  tags:
    - aliyun-sit-runner
  needs:
    - job: verify-rc-integration
  variables:
    GITHUB_REPO: "dana-id/dana-go"
  before_script:
    - apk add --no-cache git rsync
    - git config --global user.name "GitLab CI"
    - git config --global user.email "ci@dana.id"
  script:
    - echo "Preparing to sync to GitHub..."
    - git clone https://oauth2:${GITHUB_TOKEN}@github.com/${GITHUB_REPO}.git /tmp/github-sync || mkdir -p /tmp/github-sync
    - cd /tmp/github-sync
    # If repository exists, use it; otherwise initialize a new one
    - |
      if [ -d ".git" ]; then
        echo "Using existing repository"
        git checkout main || git checkout -b main
      else
        echo "Initializing new repository"
        git init
        git config user.name "GitLab CI"
        git config user.email "ci@dana.id"
        git remote add origin https://oauth2:${GITHUB_TOKEN}@github.com/${GITHUB_REPO}.git
        git branch -M main
      fi
    - echo "Copying files from project directory..."
    - cd $CI_PROJECT_DIR
    - rsync -av --ignore-errors --exclude=".git/" --exclude=".gitlab-ci.yml" --exclude=".gitignore" --exclude=".pytest_cache/" --exclude="__pycache__/" --exclude="*.pyc" --exclude="ci/" ./ /tmp/github-sync/
    - cd /tmp/github-sync
    - git add .
    - git diff --staged --quiet || git commit -m "Generated DANA Go SDK"
    - echo "Pushing to GitHub..."
    - git push https://oauth2:${GITHUB_TOKEN}@github.com/${GITHUB_REPO}.git main
    # Create and push tag on main branch
    - git tag ${CI_COMMIT_TAG}
    - git push https://oauth2:${GITHUB_TOKEN}@github.com/${GITHUB_REPO}.git ${CI_COMMIT_TAG}
    # After push, verify module is available through proxy.golang.org
    - export TAG=${CI_COMMIT_TAG#v}
    - GOPROXY=proxy.golang.org go list -m github.com/dana-id/dana-go@${CI_COMMIT_TAG}
  rules:
    - if: '$CI_COMMIT_TAG =~ /^v\d+\.\d+\.\d+$/'
      when: on_success

.dependabot:
  image:
    name: docker.io/andrcuns/dependabot-gitlab-gomod:latest
    entrypoint: [""]
  variables:
    GIT_STRATEGY: none
    PACKAGE_MANAGER: $CI_JOB_NAME
    RAILS_ENV: production
    SETTINGS__GITLAB_URL: $CI_SERVER_URL
    SETTINGS__STANDALONE: "true"
  before_script:
    - cd /home/dependabot/app
  script:
    - bundle exec rake "dependabot:update[$CI_PROJECT_NAMESPACE/$CI_PROJECT_NAME,$PACKAGE_MANAGER,/]"
  rules:
    - if: '$CI_PIPELINE_SOURCE == "schedule" && $SCHEDULE_NAME == "dependabot"'
  tags:
    - aliyun-sit-runner

gomod:
  extends: .dependabot