/*
IPG Cashier Pay API

API for enabling the user to make payment from merchant's platform with redirecting to DANA's platform.

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package ipg

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"fmt"
	"encoding/json"

	common "github.com/dana-id/go_client/common"
	config "github.com/dana-id/go_client/config"
	exceptions "github.com/dana-id/go_client/exceptions"
	utils "github.com/dana-id/go_client/utils"
)


// IPGAPIService IPGAPI service
type IPGAPIService struct {
	common.ClientInterface
	cfg *config.Configuration
}

// NewIPGAPIService creates a new IPGAPI with the provided client
func NewIPGAPIService(client common.ClientInterface) *IPGAPIService {
	// Extract configuration if available through our DanaConfigProvider interface
	var cfg *config.Configuration
	if provider, ok := client.(interface{ GetDanaConfig() *config.Configuration }); ok {
		cfg = provider.GetDanaConfig()
	}
	
	return &IPGAPIService{
		ClientInterface: client,
		cfg: cfg,
	}
}

type ApiAccountUnbindingRequest struct {
	ctx context.Context
	ApiService *IPGAPIService
	accountUnbindingRequest *AccountUnbindingRequest
}

func (r ApiAccountUnbindingRequest) AccountUnbindingRequest(accountUnbindingRequest AccountUnbindingRequest) ApiAccountUnbindingRequest {
	r.accountUnbindingRequest = &accountUnbindingRequest
	return r
}

func (r ApiAccountUnbindingRequest) Execute() (*AccountUnbindingResponse, *http.Response, error) {
	return r.ApiService.AccountUnbindingExecute(r)
}

/*
AccountUnbinding Account unbinding - Binding

This API is used to reverses the account binding process by revoking the accessToken and refreshToken

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAccountUnbindingRequest
*/
func (a *IPGAPIService) AccountUnbinding(ctx context.Context) ApiAccountUnbindingRequest {
	return ApiAccountUnbindingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AccountUnbindingResponse
func (a *IPGAPIService) AccountUnbindingExecute(r ApiAccountUnbindingRequest) (*AccountUnbindingResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []common.FormFile
		localVarReturnValue  *AccountUnbindingResponse
	)

	localBasePath, err := a.GetConfig().ServerURLWithContext(r.ctx, "IPGAPIService.AccountUnbinding")
	if err != nil {
		return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
			ErrorMsg: err.Error(),
		}
	}

	localVarPath := localBasePath + "/v1.0/registration-account-unbinding.htm"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountUnbindingRequest == nil {
		return localVarReturnValue, nil, utils.ReportError("accountUnbindingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := utils.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := utils.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.accountUnbindingRequest
	// Set API Key Authentication headers using centralized utility function
	if a.GetConfig() != nil && a.GetConfig().APIKey != nil {
		// Process request body for authentication if present
		var dataForSnapStr string
		dst := &bytes.Buffer{}
		dataForSnap, err := json.Marshal(localVarPostBody)
		if err != nil {
			return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
				ErrorMsg: fmt.Sprintf("Failed to marshal request: %v", err),
			}
		}

		err = json.Compact(dst, dataForSnap)
		if err != nil {
			return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
				ErrorMsg: err.Error(),
			}
		}
		dataForSnapStr = string(dst.Bytes())
		utils.SetSnapHeaders(localVarHeaderParams, a.GetConfig().APIKey, dataForSnapStr, localVarHTTPMethod, localVarPath)
		
	}
	req, err := a.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &exceptions.GenericOpenAPIError{
			RawBody:  localVarBody,
			ErrorMsg: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	// Return body data
	
	if localVarHTTPResponse.StatusCode >= 200 && localVarHTTPResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err == nil { 
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}
		return localVarReturnValue, localVarHTTPResponse, nil
}
type ApiApplyOTTRequest struct {
	ctx context.Context
	ApiService *IPGAPIService
	applyOTTRequest *ApplyOTTRequest
}

func (r ApiApplyOTTRequest) ApplyOTTRequest(applyOTTRequest ApplyOTTRequest) ApiApplyOTTRequest {
	r.applyOTTRequest = &applyOTTRequest
	return r
}

func (r ApiApplyOTTRequest) Execute() (*ApplyOTTResponse, *http.Response, error) {
	return r.ApiService.ApplyOTTExecute(r)
}

/*
ApplyOTT Apply OTT - IPG

This API is used to get one time token that will be used as authorization parameter upon redirecting to DANA

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApplyOTTRequest
*/
func (a *IPGAPIService) ApplyOTT(ctx context.Context) ApiApplyOTTRequest {
	return ApiApplyOTTRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApplyOTTResponse
func (a *IPGAPIService) ApplyOTTExecute(r ApiApplyOTTRequest) (*ApplyOTTResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []common.FormFile
		localVarReturnValue  *ApplyOTTResponse
	)

	localBasePath, err := a.GetConfig().ServerURLWithContext(r.ctx, "IPGAPIService.ApplyOTT")
	if err != nil {
		return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
			ErrorMsg: err.Error(),
		}
	}

	localVarPath := localBasePath + "/rest/v1.1/qr/apply-ott"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.applyOTTRequest == nil {
		return localVarReturnValue, nil, utils.ReportError("applyOTTRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := utils.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := utils.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.applyOTTRequest
	// Set API Key Authentication headers using centralized utility function
	if a.GetConfig() != nil && a.GetConfig().APIKey != nil {
		// Process request body for authentication if present
		var dataForSnapStr string
		dst := &bytes.Buffer{}
		dataForSnap, err := json.Marshal(localVarPostBody)
		if err != nil {
			return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
				ErrorMsg: fmt.Sprintf("Failed to marshal request: %v", err),
			}
		}

		err = json.Compact(dst, dataForSnap)
		if err != nil {
			return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
				ErrorMsg: err.Error(),
			}
		}
		dataForSnapStr = string(dst.Bytes())
		utils.SetSnapHeaders(localVarHeaderParams, a.GetConfig().APIKey, dataForSnapStr, localVarHTTPMethod, localVarPath)
		
	}
	req, err := a.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &exceptions.GenericOpenAPIError{
			RawBody:  localVarBody,
			ErrorMsg: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	// Return body data
	
	if localVarHTTPResponse.StatusCode >= 200 && localVarHTTPResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err == nil { 
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}
		return localVarReturnValue, localVarHTTPResponse, nil
}
type ApiApplyTokenRequest struct {
	ctx context.Context
	ApiService *IPGAPIService
	applyTokenRequest *ApplyTokenRequest
}

func (r ApiApplyTokenRequest) ApplyTokenRequest(applyTokenRequest ApplyTokenRequest) ApiApplyTokenRequest {
	r.applyTokenRequest = &applyTokenRequest
	return r
}

func (r ApiApplyTokenRequest) Execute() (*ApplyTokenResponse, *http.Response, error) {
	return r.ApiService.ApplyTokenExecute(r)
}

/*
ApplyToken Apply Token, required by Apply OTT - Binding

This API is used to finalized account binding process by exchanging the authCode into accessToken that can be used as user authorization

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApplyTokenRequest
*/
func (a *IPGAPIService) ApplyToken(ctx context.Context) ApiApplyTokenRequest {
	return ApiApplyTokenRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApplyTokenResponse
func (a *IPGAPIService) ApplyTokenExecute(r ApiApplyTokenRequest) (*ApplyTokenResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []common.FormFile
		localVarReturnValue  *ApplyTokenResponse
	)

	localBasePath, err := a.GetConfig().ServerURLWithContext(r.ctx, "IPGAPIService.ApplyToken")
	if err != nil {
		return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
			ErrorMsg: err.Error(),
		}
	}

	localVarPath := localBasePath + "/v1.0/access-token/b2b2c.htm"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.applyTokenRequest == nil {
		return localVarReturnValue, nil, utils.ReportError("applyTokenRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := utils.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := utils.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.applyTokenRequest
	// Set API Key Authentication headers using centralized utility function
	if a.GetConfig() != nil && a.GetConfig().APIKey != nil {
		// Process request body for authentication if present
		var dataForSnapStr string
		dst := &bytes.Buffer{}
		dataForSnap, err := json.Marshal(localVarPostBody)
		if err != nil {
			return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
				ErrorMsg: fmt.Sprintf("Failed to marshal request: %v", err),
			}
		}

		err = json.Compact(dst, dataForSnap)
		if err != nil {
			return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
				ErrorMsg: err.Error(),
			}
		}
		dataForSnapStr = string(dst.Bytes())
		utils.SetSnapHeaders(localVarHeaderParams, a.GetConfig().APIKey, dataForSnapStr, localVarHTTPMethod, localVarPath)
		
	}
	req, err := a.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &exceptions.GenericOpenAPIError{
			RawBody:  localVarBody,
			ErrorMsg: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	// Return body data
	
	if localVarHTTPResponse.StatusCode >= 200 && localVarHTTPResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err == nil { 
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}
		return localVarReturnValue, localVarHTTPResponse, nil
}
type ApiCancelOrderRequest struct {
	ctx context.Context
	ApiService *IPGAPIService
	cancelOrderRequest *CancelOrderRequest
}

func (r ApiCancelOrderRequest) CancelOrderRequest(cancelOrderRequest CancelOrderRequest) ApiCancelOrderRequest {
	r.cancelOrderRequest = &cancelOrderRequest
	return r
}

func (r ApiCancelOrderRequest) Execute() (*CancelOrderResponse, *http.Response, error) {
	return r.ApiService.CancelOrderExecute(r)
}

/*
CancelOrder Cancel Order - IPG

This API is used to cancel the order from merchant's platform to DANA

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCancelOrderRequest
*/
func (a *IPGAPIService) CancelOrder(ctx context.Context) ApiCancelOrderRequest {
	return ApiCancelOrderRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CancelOrderResponse
func (a *IPGAPIService) CancelOrderExecute(r ApiCancelOrderRequest) (*CancelOrderResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []common.FormFile
		localVarReturnValue  *CancelOrderResponse
	)

	localBasePath, err := a.GetConfig().ServerURLWithContext(r.ctx, "IPGAPIService.CancelOrder")
	if err != nil {
		return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
			ErrorMsg: err.Error(),
		}
	}

	localVarPath := localBasePath + "/v1.0/debit/cancel.htm"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cancelOrderRequest == nil {
		return localVarReturnValue, nil, utils.ReportError("cancelOrderRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := utils.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := utils.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.cancelOrderRequest
	// Set API Key Authentication headers using centralized utility function
	if a.GetConfig() != nil && a.GetConfig().APIKey != nil {
		// Process request body for authentication if present
		var dataForSnapStr string
		dst := &bytes.Buffer{}
		dataForSnap, err := json.Marshal(localVarPostBody)
		if err != nil {
			return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
				ErrorMsg: fmt.Sprintf("Failed to marshal request: %v", err),
			}
		}

		err = json.Compact(dst, dataForSnap)
		if err != nil {
			return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
				ErrorMsg: err.Error(),
			}
		}
		dataForSnapStr = string(dst.Bytes())
		utils.SetSnapHeaders(localVarHeaderParams, a.GetConfig().APIKey, dataForSnapStr, localVarHTTPMethod, localVarPath)
		
	}
	req, err := a.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &exceptions.GenericOpenAPIError{
			RawBody:  localVarBody,
			ErrorMsg: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	// Return body data
	
	if localVarHTTPResponse.StatusCode >= 200 && localVarHTTPResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err == nil { 
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}
		return localVarReturnValue, localVarHTTPResponse, nil
}
type ApiIpgPaymentRequest struct {
	ctx context.Context
	ApiService *IPGAPIService
	iPGPaymentRequest *IPGPaymentRequest
}

func (r ApiIpgPaymentRequest) IPGPaymentRequest(iPGPaymentRequest IPGPaymentRequest) ApiIpgPaymentRequest {
	r.iPGPaymentRequest = &iPGPaymentRequest
	return r
}

func (r ApiIpgPaymentRequest) Execute() (*IPGPaymentResponse, *http.Response, error) {
	return r.ApiService.IpgPaymentExecute(r)
}

/*
IpgPayment IPG payment - IPG

This API is used to initiate payment from merchant's platform to DANA

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpgPaymentRequest
*/
func (a *IPGAPIService) IpgPayment(ctx context.Context) ApiIpgPaymentRequest {
	return ApiIpgPaymentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return IPGPaymentResponse
func (a *IPGAPIService) IpgPaymentExecute(r ApiIpgPaymentRequest) (*IPGPaymentResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []common.FormFile
		localVarReturnValue  *IPGPaymentResponse
	)

	localBasePath, err := a.GetConfig().ServerURLWithContext(r.ctx, "IPGAPIService.IpgPayment")
	if err != nil {
		return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
			ErrorMsg: err.Error(),
		}
	}

	localVarPath := localBasePath + "/rest/redirection/v1.0/debit/payment-host-to-host"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.iPGPaymentRequest == nil {
		return localVarReturnValue, nil, utils.ReportError("iPGPaymentRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := utils.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := utils.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.iPGPaymentRequest
	// Set API Key Authentication headers using centralized utility function
	if a.GetConfig() != nil && a.GetConfig().APIKey != nil {
		// Process request body for authentication if present
		var dataForSnapStr string
		dst := &bytes.Buffer{}
		dataForSnap, err := json.Marshal(localVarPostBody)
		if err != nil {
			return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
				ErrorMsg: fmt.Sprintf("Failed to marshal request: %v", err),
			}
		}

		err = json.Compact(dst, dataForSnap)
		if err != nil {
			return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
				ErrorMsg: err.Error(),
			}
		}
		dataForSnapStr = string(dst.Bytes())
		utils.SetSnapHeaders(localVarHeaderParams, a.GetConfig().APIKey, dataForSnapStr, localVarHTTPMethod, localVarPath)
		
	}
	req, err := a.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &exceptions.GenericOpenAPIError{
			RawBody:  localVarBody,
			ErrorMsg: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	// Return body data
	
	if localVarHTTPResponse.StatusCode >= 200 && localVarHTTPResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err == nil { 
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}
		return localVarReturnValue, localVarHTTPResponse, nil
}
type ApiQueryPaymentRequest struct {
	ctx context.Context
	ApiService *IPGAPIService
	queryPaymentRequest *QueryPaymentRequest
}

func (r ApiQueryPaymentRequest) QueryPaymentRequest(queryPaymentRequest QueryPaymentRequest) ApiQueryPaymentRequest {
	r.queryPaymentRequest = &queryPaymentRequest
	return r
}

func (r ApiQueryPaymentRequest) Execute() (*QueryPaymentResponse, *http.Response, error) {
	return r.ApiService.QueryPaymentExecute(r)
}

/*
QueryPayment Query Payment - IPG

This API is used to inquiry payment status and information from merchant's platform to DANA

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQueryPaymentRequest
*/
func (a *IPGAPIService) QueryPayment(ctx context.Context) ApiQueryPaymentRequest {
	return ApiQueryPaymentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QueryPaymentResponse
func (a *IPGAPIService) QueryPaymentExecute(r ApiQueryPaymentRequest) (*QueryPaymentResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []common.FormFile
		localVarReturnValue  *QueryPaymentResponse
	)

	localBasePath, err := a.GetConfig().ServerURLWithContext(r.ctx, "IPGAPIService.QueryPayment")
	if err != nil {
		return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
			ErrorMsg: err.Error(),
		}
	}

	localVarPath := localBasePath + "/rest/v1.1/debit/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.queryPaymentRequest == nil {
		return localVarReturnValue, nil, utils.ReportError("queryPaymentRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := utils.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := utils.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.queryPaymentRequest
	// Set API Key Authentication headers using centralized utility function
	if a.GetConfig() != nil && a.GetConfig().APIKey != nil {
		// Process request body for authentication if present
		var dataForSnapStr string
		dst := &bytes.Buffer{}
		dataForSnap, err := json.Marshal(localVarPostBody)
		if err != nil {
			return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
				ErrorMsg: fmt.Sprintf("Failed to marshal request: %v", err),
			}
		}

		err = json.Compact(dst, dataForSnap)
		if err != nil {
			return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
				ErrorMsg: err.Error(),
			}
		}
		dataForSnapStr = string(dst.Bytes())
		utils.SetSnapHeaders(localVarHeaderParams, a.GetConfig().APIKey, dataForSnapStr, localVarHTTPMethod, localVarPath)
		
	}
	req, err := a.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &exceptions.GenericOpenAPIError{
			RawBody:  localVarBody,
			ErrorMsg: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	// Return body data
	
	if localVarHTTPResponse.StatusCode >= 200 && localVarHTTPResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err == nil { 
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}
		return localVarReturnValue, localVarHTTPResponse, nil
}
type ApiRefundOrderRequest struct {
	ctx context.Context
	ApiService *IPGAPIService
	refundOrderRequest *RefundOrderRequest
}

func (r ApiRefundOrderRequest) RefundOrderRequest(refundOrderRequest RefundOrderRequest) ApiRefundOrderRequest {
	r.refundOrderRequest = &refundOrderRequest
	return r
}

func (r ApiRefundOrderRequest) Execute() (*RefundOrderResponse, *http.Response, error) {
	return r.ApiService.RefundOrderExecute(r)
}

/*
RefundOrder Refund Order - IPG

This API is used to refund the order from merchant's platform to DANA

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRefundOrderRequest
*/
func (a *IPGAPIService) RefundOrder(ctx context.Context) ApiRefundOrderRequest {
	return ApiRefundOrderRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RefundOrderResponse
func (a *IPGAPIService) RefundOrderExecute(r ApiRefundOrderRequest) (*RefundOrderResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []common.FormFile
		localVarReturnValue  *RefundOrderResponse
	)

	localBasePath, err := a.GetConfig().ServerURLWithContext(r.ctx, "IPGAPIService.RefundOrder")
	if err != nil {
		return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
			ErrorMsg: err.Error(),
		}
	}

	localVarPath := localBasePath + "/v1.0/debit/refund.htm"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.refundOrderRequest == nil {
		return localVarReturnValue, nil, utils.ReportError("refundOrderRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := utils.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := utils.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.refundOrderRequest
	// Set API Key Authentication headers using centralized utility function
	if a.GetConfig() != nil && a.GetConfig().APIKey != nil {
		// Process request body for authentication if present
		var dataForSnapStr string
		dst := &bytes.Buffer{}
		dataForSnap, err := json.Marshal(localVarPostBody)
		if err != nil {
			return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
				ErrorMsg: fmt.Sprintf("Failed to marshal request: %v", err),
			}
		}

		err = json.Compact(dst, dataForSnap)
		if err != nil {
			return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
				ErrorMsg: err.Error(),
			}
		}
		dataForSnapStr = string(dst.Bytes())
		utils.SetSnapHeaders(localVarHeaderParams, a.GetConfig().APIKey, dataForSnapStr, localVarHTTPMethod, localVarPath)
		
	}
	req, err := a.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &exceptions.GenericOpenAPIError{
			RawBody:  localVarBody,
			ErrorMsg: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	// Return body data
	
	if localVarHTTPResponse.StatusCode >= 200 && localVarHTTPResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err == nil { 
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}
		return localVarReturnValue, localVarHTTPResponse, nil
}
