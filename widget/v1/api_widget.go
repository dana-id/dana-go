// Copyright 2025 PT Espay Debit Indonesia Koe
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package widget

/*
Widget API

API for enabling the user to make payment from merchant's platform with redirecting to DANA's platform.

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.


import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"fmt"
	"encoding/json"

	common "github.com/dana-id/dana-go/common"
	config "github.com/dana-id/dana-go/config"
	exceptions "github.com/dana-id/dana-go/exceptions"
	utils "github.com/dana-id/dana-go/utils"
)


// WidgetAPIService WidgetAPI service
type WidgetAPIService struct {
	common.ClientInterface
	cfg *config.Configuration
}

// NewWidgetAPIService creates a new WidgetAPI with the provided client
func NewWidgetAPIService(client common.ClientInterface) *WidgetAPIService {
	// Extract configuration if available through our DanaConfigProvider interface
	var cfg *config.Configuration
	if provider, ok := client.(interface{ GetDanaConfig() *config.Configuration }); ok {
		cfg = provider.GetDanaConfig()
	}
	
	return &WidgetAPIService{
		ClientInterface: client,
		cfg: cfg,
	}
}

type ApiAccountUnbindingRequest struct {
	ctx context.Context
	ApiService *WidgetAPIService
	accountUnbindingRequest *AccountUnbindingRequest
}

func (r ApiAccountUnbindingRequest) AccountUnbindingRequest(accountUnbindingRequest AccountUnbindingRequest) ApiAccountUnbindingRequest {
	r.accountUnbindingRequest = &accountUnbindingRequest
	return r
}

func (r ApiAccountUnbindingRequest) Execute() (*AccountUnbindingResponse, *http.Response, error) {
	return r.ApiService.AccountUnbindingExecute(r)
}

/*
AccountUnbinding Account unbinding - Binding

This API is used to reverses the account binding process by revoking the accessToken and refreshToken

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAccountUnbindingRequest
*/
func (a *WidgetAPIService) AccountUnbinding(ctx context.Context) ApiAccountUnbindingRequest {
	return ApiAccountUnbindingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AccountUnbindingResponse
func (a *WidgetAPIService) AccountUnbindingExecute(r ApiAccountUnbindingRequest) (*AccountUnbindingResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []common.FormFile
		localVarReturnValue  *AccountUnbindingResponse
	)

	localBasePath, err := a.GetConfig().ServerURLWithContext(r.ctx, "WidgetAPIService.AccountUnbinding")
	if err != nil {
		return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
			ErrorMsg: err.Error(),
		}
	}

	localVarPath := localBasePath + "/v1.0/registration-account-unbinding.htm"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountUnbindingRequest == nil {
		return localVarReturnValue, nil, utils.ReportError("accountUnbindingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := utils.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := utils.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.accountUnbindingRequest
	// Set API Key Authentication headers using centralized utility function
	if a.GetConfig() != nil && a.GetConfig().APIKey != nil {
		// Process request body for authentication if present
		var dataForSnapStr string
		dst := &bytes.Buffer{}
		dataForSnap, err := json.Marshal(localVarPostBody)
		if err != nil {
			return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
				ErrorMsg: fmt.Sprintf("Failed to marshal request: %v", err),
			}
		}

		err = json.Compact(dst, dataForSnap)
		if err != nil {
			return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
				ErrorMsg: err.Error(),
			}
		}
		dataForSnapStr = string(dst.Bytes())

		// SNAP signature scenario: ACCOUNT UNBINDING
		utils.SetSnapHeaders(localVarHeaderParams, a.GetConfig().APIKey, dataForSnapStr, localVarHTTPMethod, localVarPath, "unbinding_account")
	}
	req, err := a.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &exceptions.GenericOpenAPIError{
			RawBody:  localVarBody,
			ErrorMsg: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	// Return body data
	
	if localVarHTTPResponse.StatusCode >= 200 && localVarHTTPResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err == nil { 
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}
		return localVarReturnValue, localVarHTTPResponse, nil
}
type ApiApplyOTTRequest struct {
	ctx context.Context
	ApiService *WidgetAPIService
	applyOTTRequest *ApplyOTTRequest
}

func (r ApiApplyOTTRequest) ApplyOTTRequest(applyOTTRequest ApplyOTTRequest) ApiApplyOTTRequest {
	r.applyOTTRequest = &applyOTTRequest
	return r
}

func (r ApiApplyOTTRequest) Execute() (*ApplyOTTResponse, *http.Response, error) {
	return r.ApiService.ApplyOTTExecute(r)
}

/*
ApplyOTT Apply OTT - Widget

This API is used to get one time token that will be used as authorization parameter upon redirecting to DANA

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApplyOTTRequest
*/
func (a *WidgetAPIService) ApplyOTT(ctx context.Context) ApiApplyOTTRequest {
	return ApiApplyOTTRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApplyOTTResponse
func (a *WidgetAPIService) ApplyOTTExecute(r ApiApplyOTTRequest) (*ApplyOTTResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []common.FormFile
		localVarReturnValue  *ApplyOTTResponse
	)

	localBasePath, err := a.GetConfig().ServerURLWithContext(r.ctx, "WidgetAPIService.ApplyOTT")
	if err != nil {
		return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
			ErrorMsg: err.Error(),
		}
	}

	localVarPath := localBasePath + "/rest/v1.1/qr/apply-ott"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.applyOTTRequest == nil {
		return localVarReturnValue, nil, utils.ReportError("applyOTTRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := utils.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := utils.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.applyOTTRequest
	// Set API Key Authentication headers using centralized utility function
	if a.GetConfig() != nil && a.GetConfig().APIKey != nil {
		// Process request body for authentication if present
		var dataForSnapStr string
		dst := &bytes.Buffer{}
		dataForSnap, err := json.Marshal(localVarPostBody)
		if err != nil {
			return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
				ErrorMsg: fmt.Sprintf("Failed to marshal request: %v", err),
			}
		}

		err = json.Compact(dst, dataForSnap)
		if err != nil {
			return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
				ErrorMsg: err.Error(),
			}
		}
		dataForSnapStr = string(dst.Bytes())

		// SNAP signature scenario: APPLY OTT
		utils.SetSnapHeaders(localVarHeaderParams, a.GetConfig().APIKey, dataForSnapStr, localVarHTTPMethod, localVarPath, "apply_ott")
	}
	req, err := a.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &exceptions.GenericOpenAPIError{
			RawBody:  localVarBody,
			ErrorMsg: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	// Return body data
	
	if localVarHTTPResponse.StatusCode >= 200 && localVarHTTPResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err == nil { 
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}
		return localVarReturnValue, localVarHTTPResponse, nil
}
type ApiApplyTokenRequest struct {
	ctx context.Context
	ApiService *WidgetAPIService
	applyTokenRequest *ApplyTokenRequest
}

func (r ApiApplyTokenRequest) ApplyTokenRequest(applyTokenRequest ApplyTokenRequest) ApiApplyTokenRequest {
	r.applyTokenRequest = &applyTokenRequest
	return r
}

func (r ApiApplyTokenRequest) Execute() (*ApplyTokenResponse, *http.Response, error) {
	return r.ApiService.ApplyTokenExecute(r)
}

/*
ApplyToken Apply Token, required by Apply OTT - Binding

This API is used to finalized account binding process by exchanging the authCode into accessToken that can be used as user authorization

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApplyTokenRequest
*/
func (a *WidgetAPIService) ApplyToken(ctx context.Context) ApiApplyTokenRequest {
	return ApiApplyTokenRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApplyTokenResponse
func (a *WidgetAPIService) ApplyTokenExecute(r ApiApplyTokenRequest) (*ApplyTokenResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []common.FormFile
		localVarReturnValue  *ApplyTokenResponse
	)

	localBasePath, err := a.GetConfig().ServerURLWithContext(r.ctx, "WidgetAPIService.ApplyToken")
	if err != nil {
		return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
			ErrorMsg: err.Error(),
		}
	}

	localVarPath := localBasePath + "/v1.0/access-token/b2b2c.htm"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.applyTokenRequest == nil {
		return localVarReturnValue, nil, utils.ReportError("applyTokenRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := utils.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := utils.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.applyTokenRequest
	// Set API Key Authentication headers using centralized utility function
	if a.GetConfig() != nil && a.GetConfig().APIKey != nil {
		// Process request body for authentication if present
		var dataForSnapStr string
		dst := &bytes.Buffer{}
		dataForSnap, err := json.Marshal(localVarPostBody)
		if err != nil {
			return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
				ErrorMsg: fmt.Sprintf("Failed to marshal request: %v", err),
			}
		}

		err = json.Compact(dst, dataForSnap)
		if err != nil {
			return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
				ErrorMsg: err.Error(),
			}
		}
		dataForSnapStr = string(dst.Bytes())

		// SNAP signature scenario: APPLY TOKEN
		utils.SetSnapHeaders(localVarHeaderParams, a.GetConfig().APIKey, dataForSnapStr, localVarHTTPMethod, localVarPath, "apply_token")
	}
	req, err := a.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &exceptions.GenericOpenAPIError{
			RawBody:  localVarBody,
			ErrorMsg: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	// Return body data
	
	if localVarHTTPResponse.StatusCode >= 200 && localVarHTTPResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err == nil { 
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}
		return localVarReturnValue, localVarHTTPResponse, nil
}
type ApiBalanceInquiryRequest struct {
	ctx context.Context
	ApiService *WidgetAPIService
	balanceInquiryRequest *BalanceInquiryRequest
}

func (r ApiBalanceInquiryRequest) BalanceInquiryRequest(balanceInquiryRequest BalanceInquiryRequest) ApiBalanceInquiryRequest {
	r.balanceInquiryRequest = &balanceInquiryRequest
	return r
}

func (r ApiBalanceInquiryRequest) Execute() (*BalanceInquiryResponse, *http.Response, error) {
	return r.ApiService.BalanceInquiryExecute(r)
}

/*
BalanceInquiry Balance Inquiry

This API is used to query user's DANA account balance via merchant

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBalanceInquiryRequest
*/
func (a *WidgetAPIService) BalanceInquiry(ctx context.Context) ApiBalanceInquiryRequest {
	return ApiBalanceInquiryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BalanceInquiryResponse
func (a *WidgetAPIService) BalanceInquiryExecute(r ApiBalanceInquiryRequest) (*BalanceInquiryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []common.FormFile
		localVarReturnValue  *BalanceInquiryResponse
	)

	localBasePath, err := a.GetConfig().ServerURLWithContext(r.ctx, "WidgetAPIService.BalanceInquiry")
	if err != nil {
		return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
			ErrorMsg: err.Error(),
		}
	}

	localVarPath := localBasePath + "/v1.0/balance-inquiry.htm"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.balanceInquiryRequest == nil {
		return localVarReturnValue, nil, utils.ReportError("balanceInquiryRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := utils.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := utils.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.balanceInquiryRequest
	// Set API Key Authentication headers using centralized utility function
	if a.GetConfig() != nil && a.GetConfig().APIKey != nil {
		// Process request body for authentication if present
		var dataForSnapStr string
		dst := &bytes.Buffer{}
		dataForSnap, err := json.Marshal(localVarPostBody)
		if err != nil {
			return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
				ErrorMsg: fmt.Sprintf("Failed to marshal request: %v", err),
			}
		}

		err = json.Compact(dst, dataForSnap)
		if err != nil {
			return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
				ErrorMsg: err.Error(),
			}
		}
		dataForSnapStr = string(dst.Bytes())

		// Default B2B signature scenario
		utils.SetSnapHeaders(localVarHeaderParams, a.GetConfig().APIKey, dataForSnapStr, localVarHTTPMethod, localVarPath, "")
	}
	req, err := a.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &exceptions.GenericOpenAPIError{
			RawBody:  localVarBody,
			ErrorMsg: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	// Return body data
	
	if localVarHTTPResponse.StatusCode >= 200 && localVarHTTPResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err == nil { 
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}
		return localVarReturnValue, localVarHTTPResponse, nil
}
type ApiCancelOrderRequest struct {
	ctx context.Context
	ApiService *WidgetAPIService
	cancelOrderRequest *CancelOrderRequest
}

func (r ApiCancelOrderRequest) CancelOrderRequest(cancelOrderRequest CancelOrderRequest) ApiCancelOrderRequest {
	r.cancelOrderRequest = &cancelOrderRequest
	return r
}

func (r ApiCancelOrderRequest) Execute() (*CancelOrderResponse, *http.Response, error) {
	return r.ApiService.CancelOrderExecute(r)
}

/*
CancelOrder Cancel Order - Widget

This API is used to cancel the order from merchant's platform to DANA

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCancelOrderRequest
*/
func (a *WidgetAPIService) CancelOrder(ctx context.Context) ApiCancelOrderRequest {
	return ApiCancelOrderRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CancelOrderResponse
func (a *WidgetAPIService) CancelOrderExecute(r ApiCancelOrderRequest) (*CancelOrderResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []common.FormFile
		localVarReturnValue  *CancelOrderResponse
	)

	localBasePath, err := a.GetConfig().ServerURLWithContext(r.ctx, "WidgetAPIService.CancelOrder")
	if err != nil {
		return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
			ErrorMsg: err.Error(),
		}
	}

	localVarPath := localBasePath + "/v1.0/debit/cancel.htm"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cancelOrderRequest == nil {
		return localVarReturnValue, nil, utils.ReportError("cancelOrderRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := utils.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := utils.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.cancelOrderRequest
	// Set API Key Authentication headers using centralized utility function
	if a.GetConfig() != nil && a.GetConfig().APIKey != nil {
		// Process request body for authentication if present
		var dataForSnapStr string
		dst := &bytes.Buffer{}
		dataForSnap, err := json.Marshal(localVarPostBody)
		if err != nil {
			return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
				ErrorMsg: fmt.Sprintf("Failed to marshal request: %v", err),
			}
		}

		err = json.Compact(dst, dataForSnap)
		if err != nil {
			return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
				ErrorMsg: err.Error(),
			}
		}
		dataForSnapStr = string(dst.Bytes())

		// Default B2B signature scenario
		utils.SetSnapHeaders(localVarHeaderParams, a.GetConfig().APIKey, dataForSnapStr, localVarHTTPMethod, localVarPath, "")
	}
	req, err := a.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &exceptions.GenericOpenAPIError{
			RawBody:  localVarBody,
			ErrorMsg: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	// Return body data
	
	if localVarHTTPResponse.StatusCode >= 200 && localVarHTTPResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err == nil { 
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}
		return localVarReturnValue, localVarHTTPResponse, nil
}
type ApiQueryPaymentRequest struct {
	ctx context.Context
	ApiService *WidgetAPIService
	queryPaymentRequest *QueryPaymentRequest
}

func (r ApiQueryPaymentRequest) QueryPaymentRequest(queryPaymentRequest QueryPaymentRequest) ApiQueryPaymentRequest {
	r.queryPaymentRequest = &queryPaymentRequest
	return r
}

func (r ApiQueryPaymentRequest) Execute() (*QueryPaymentResponse, *http.Response, error) {
	return r.ApiService.QueryPaymentExecute(r)
}

/*
QueryPayment Query Payment - Widget

This API is used to inquiry payment status and information from merchant's platform to DANA

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQueryPaymentRequest
*/
func (a *WidgetAPIService) QueryPayment(ctx context.Context) ApiQueryPaymentRequest {
	return ApiQueryPaymentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QueryPaymentResponse
func (a *WidgetAPIService) QueryPaymentExecute(r ApiQueryPaymentRequest) (*QueryPaymentResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []common.FormFile
		localVarReturnValue  *QueryPaymentResponse
	)

	localBasePath, err := a.GetConfig().ServerURLWithContext(r.ctx, "WidgetAPIService.QueryPayment")
	if err != nil {
		return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
			ErrorMsg: err.Error(),
		}
	}

	localVarPath := localBasePath + "/rest/v1.1/debit/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.queryPaymentRequest == nil {
		return localVarReturnValue, nil, utils.ReportError("queryPaymentRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := utils.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := utils.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.queryPaymentRequest
	// Set API Key Authentication headers using centralized utility function
	if a.GetConfig() != nil && a.GetConfig().APIKey != nil {
		// Process request body for authentication if present
		var dataForSnapStr string
		dst := &bytes.Buffer{}
		dataForSnap, err := json.Marshal(localVarPostBody)
		if err != nil {
			return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
				ErrorMsg: fmt.Sprintf("Failed to marshal request: %v", err),
			}
		}

		err = json.Compact(dst, dataForSnap)
		if err != nil {
			return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
				ErrorMsg: err.Error(),
			}
		}
		dataForSnapStr = string(dst.Bytes())

		// Default B2B signature scenario
		utils.SetSnapHeaders(localVarHeaderParams, a.GetConfig().APIKey, dataForSnapStr, localVarHTTPMethod, localVarPath, "")
	}
	req, err := a.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &exceptions.GenericOpenAPIError{
			RawBody:  localVarBody,
			ErrorMsg: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	// Return body data
	
	if localVarHTTPResponse.StatusCode >= 200 && localVarHTTPResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err == nil { 
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}
		return localVarReturnValue, localVarHTTPResponse, nil
}
type ApiQueryUserProfileRequest struct {
	ctx context.Context
	ApiService *WidgetAPIService
	queryUserProfileRequest *QueryUserProfileRequest
}

func (r ApiQueryUserProfileRequest) QueryUserProfileRequest(queryUserProfileRequest QueryUserProfileRequest) ApiQueryUserProfileRequest {
	r.queryUserProfileRequest = &queryUserProfileRequest
	return r
}

func (r ApiQueryUserProfileRequest) Execute() (*QueryUserProfileResponse, *http.Response, error) {
	return r.ApiService.QueryUserProfileExecute(r)
}

/*
QueryUserProfile Query User Profile

The API is used to query user profile such as DANA balance (unit in IDR), masked DANA phone number, KYC or OTT (one time token) between merchant server and DANA's server

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQueryUserProfileRequest
*/
func (a *WidgetAPIService) QueryUserProfile(ctx context.Context) ApiQueryUserProfileRequest {
	return ApiQueryUserProfileRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QueryUserProfileResponse
func (a *WidgetAPIService) QueryUserProfileExecute(r ApiQueryUserProfileRequest) (*QueryUserProfileResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []common.FormFile
		localVarReturnValue  *QueryUserProfileResponse
	)

	localBasePath, err := a.GetConfig().ServerURLWithContext(r.ctx, "WidgetAPIService.QueryUserProfile")
	if err != nil {
		return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
			ErrorMsg: err.Error(),
		}
	}

	localVarPath := localBasePath + "/dana/member/query/queryUserProfile.htm"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.queryUserProfileRequest == nil {
		return localVarReturnValue, nil, utils.ReportError("queryUserProfileRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := utils.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := utils.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.queryUserProfileRequest
	// Set API Key Authentication headers using centralized utility function
	if a.GetConfig() != nil && a.GetConfig().APIKey != nil {
		// Process request body for authentication if present
		var dataForSnapStr string
		dst := &bytes.Buffer{}
		dataForSnap, err := json.Marshal(localVarPostBody)
		if err != nil {
			return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
				ErrorMsg: fmt.Sprintf("Failed to marshal request: %v", err),
			}
		}

		err = json.Compact(dst, dataForSnap)
		if err != nil {
			return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
				ErrorMsg: err.Error(),
			}
		}
		dataForSnapStr = string(dst.Bytes())

		// Default B2B signature scenario
		utils.SetSnapHeaders(localVarHeaderParams, a.GetConfig().APIKey, dataForSnapStr, localVarHTTPMethod, localVarPath, "")
	}
	req, err := a.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &exceptions.GenericOpenAPIError{
			RawBody:  localVarBody,
			ErrorMsg: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	// Return body data
	
	if localVarHTTPResponse.StatusCode >= 200 && localVarHTTPResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err == nil { 
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}
		return localVarReturnValue, localVarHTTPResponse, nil
}
type ApiRefundOrderRequest struct {
	ctx context.Context
	ApiService *WidgetAPIService
	refundOrderRequest *RefundOrderRequest
}

func (r ApiRefundOrderRequest) RefundOrderRequest(refundOrderRequest RefundOrderRequest) ApiRefundOrderRequest {
	r.refundOrderRequest = &refundOrderRequest
	return r
}

func (r ApiRefundOrderRequest) Execute() (*RefundOrderResponse, *http.Response, error) {
	return r.ApiService.RefundOrderExecute(r)
}

/*
RefundOrder Refund Order - Widget

This API is used to refund the order from merchant's platform to DANA

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRefundOrderRequest
*/
func (a *WidgetAPIService) RefundOrder(ctx context.Context) ApiRefundOrderRequest {
	return ApiRefundOrderRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RefundOrderResponse
func (a *WidgetAPIService) RefundOrderExecute(r ApiRefundOrderRequest) (*RefundOrderResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []common.FormFile
		localVarReturnValue  *RefundOrderResponse
	)

	localBasePath, err := a.GetConfig().ServerURLWithContext(r.ctx, "WidgetAPIService.RefundOrder")
	if err != nil {
		return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
			ErrorMsg: err.Error(),
		}
	}

	localVarPath := localBasePath + "/v1.0/debit/refund.htm"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.refundOrderRequest == nil {
		return localVarReturnValue, nil, utils.ReportError("refundOrderRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := utils.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := utils.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.refundOrderRequest
	// Set API Key Authentication headers using centralized utility function
	if a.GetConfig() != nil && a.GetConfig().APIKey != nil {
		// Process request body for authentication if present
		var dataForSnapStr string
		dst := &bytes.Buffer{}
		dataForSnap, err := json.Marshal(localVarPostBody)
		if err != nil {
			return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
				ErrorMsg: fmt.Sprintf("Failed to marshal request: %v", err),
			}
		}

		err = json.Compact(dst, dataForSnap)
		if err != nil {
			return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
				ErrorMsg: err.Error(),
			}
		}
		dataForSnapStr = string(dst.Bytes())

		// Default B2B signature scenario
		utils.SetSnapHeaders(localVarHeaderParams, a.GetConfig().APIKey, dataForSnapStr, localVarHTTPMethod, localVarPath, "")
	}
	req, err := a.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &exceptions.GenericOpenAPIError{
			RawBody:  localVarBody,
			ErrorMsg: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	// Return body data
	
	if localVarHTTPResponse.StatusCode >= 200 && localVarHTTPResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err == nil { 
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}
		return localVarReturnValue, localVarHTTPResponse, nil
}
type ApiWidgetPaymentRequest struct {
	ctx context.Context
	ApiService *WidgetAPIService
	widgetPaymentRequest *WidgetPaymentRequest
}

func (r ApiWidgetPaymentRequest) WidgetPaymentRequest(widgetPaymentRequest WidgetPaymentRequest) ApiWidgetPaymentRequest {
	r.widgetPaymentRequest = &widgetPaymentRequest
	return r
}

func (r ApiWidgetPaymentRequest) Execute() (*WidgetPaymentResponse, *http.Response, error) {
	return r.ApiService.WidgetPaymentExecute(r)
}

/*
WidgetPayment Widget Payment - Widget

This API is used to initiate payment from merchant's platform to DANA

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWidgetPaymentRequest
*/
func (a *WidgetAPIService) WidgetPayment(ctx context.Context) ApiWidgetPaymentRequest {
	return ApiWidgetPaymentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return WidgetPaymentResponse
func (a *WidgetAPIService) WidgetPaymentExecute(r ApiWidgetPaymentRequest) (*WidgetPaymentResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []common.FormFile
		localVarReturnValue  *WidgetPaymentResponse
	)

	localBasePath, err := a.GetConfig().ServerURLWithContext(r.ctx, "WidgetAPIService.WidgetPayment")
	if err != nil {
		return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
			ErrorMsg: err.Error(),
		}
	}

	localVarPath := localBasePath + "/rest/redirection/v1.0/debit/payment-host-to-host"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.widgetPaymentRequest == nil {
		return localVarReturnValue, nil, utils.ReportError("widgetPaymentRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := utils.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := utils.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.widgetPaymentRequest
	// Set API Key Authentication headers using centralized utility function
	if a.GetConfig() != nil && a.GetConfig().APIKey != nil {
		// Process request body for authentication if present
		var dataForSnapStr string
		dst := &bytes.Buffer{}
		dataForSnap, err := json.Marshal(localVarPostBody)
		if err != nil {
			return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
				ErrorMsg: fmt.Sprintf("Failed to marshal request: %v", err),
			}
		}

		err = json.Compact(dst, dataForSnap)
		if err != nil {
			return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
				ErrorMsg: err.Error(),
			}
		}
		dataForSnapStr = string(dst.Bytes())

		// Default B2B signature scenario
		utils.SetSnapHeaders(localVarHeaderParams, a.GetConfig().APIKey, dataForSnapStr, localVarHTTPMethod, localVarPath, "")
	}
	req, err := a.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &exceptions.GenericOpenAPIError{
			RawBody:  localVarBody,
			ErrorMsg: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	// Return body data
	
	if localVarHTTPResponse.StatusCode >= 200 && localVarHTTPResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err == nil { 
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}
		return localVarReturnValue, localVarHTTPResponse, nil
}
