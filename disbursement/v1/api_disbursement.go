// Copyright 2025 PT Espay Debit Indonesia Koe
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package disbursement

/*
Disbursement API

API for doing disbursement operations in DANA, including DANA account inquiry, transfer to DANA, and transfer to bank disbursement

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.


import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"fmt"
	"encoding/json"

	common "github.com/dana-id/dana-go/common"
	config "github.com/dana-id/dana-go/config"
	exceptions "github.com/dana-id/dana-go/exceptions"
	utils "github.com/dana-id/dana-go/utils"
)


// DisbursementAPIService DisbursementAPI service
type DisbursementAPIService struct {
	common.ClientInterface
	cfg *config.Configuration
}

// NewDisbursementAPIService creates a new DisbursementAPI with the provided client
func NewDisbursementAPIService(client common.ClientInterface) *DisbursementAPIService {
	// Extract configuration if available through our DanaConfigProvider interface
	var cfg *config.Configuration
	if provider, ok := client.(interface{ GetDanaConfig() *config.Configuration }); ok {
		cfg = provider.GetDanaConfig()
	}
	
	return &DisbursementAPIService{
		ClientInterface: client,
		cfg: cfg,
	}
}

type ApiBankAccountInquiryRequest struct {
	ctx context.Context
	ApiService *DisbursementAPIService
	bankAccountInquiryRequest *BankAccountInquiryRequest
}

func (r ApiBankAccountInquiryRequest) BankAccountInquiryRequest(bankAccountInquiryRequest BankAccountInquiryRequest) ApiBankAccountInquiryRequest {
	r.bankAccountInquiryRequest = &bankAccountInquiryRequest
	return r
}

func (r ApiBankAccountInquiryRequest) Execute() (*BankAccountInquiryResponse, *http.Response, error) {
	return r.ApiService.BankAccountInquiryExecute(r)
}

/*
BankAccountInquiry Transfer to Bank Account Inquiry

This API is used for merchant to do inquiry Bank account info via DANA

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBankAccountInquiryRequest
*/
func (a *DisbursementAPIService) BankAccountInquiry(ctx context.Context) ApiBankAccountInquiryRequest {
	return ApiBankAccountInquiryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BankAccountInquiryResponse
func (a *DisbursementAPIService) BankAccountInquiryExecute(r ApiBankAccountInquiryRequest) (*BankAccountInquiryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []common.FormFile
		localVarReturnValue  *BankAccountInquiryResponse
	)

	localBasePath, err := a.GetConfig().ServerURLWithContext(r.ctx, "DisbursementAPIService.BankAccountInquiry")
	if err != nil {
		return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
			ErrorMsg: err.Error(),
		}
	}

	localVarPath := localBasePath + "/v1.0/emoney/bank-account-inquiry.htm"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bankAccountInquiryRequest == nil {
		return localVarReturnValue, nil, utils.ReportError("bankAccountInquiryRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := utils.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := utils.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bankAccountInquiryRequest
	// Set API Key Authentication headers using centralized utility function
	if a.GetConfig() != nil && a.GetConfig().APIKey != nil {
		// Process request body for authentication if present
		var dataForSnapStr string
		dst := &bytes.Buffer{}
		dataForSnap, err := json.Marshal(localVarPostBody)
		if err != nil {
			return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
				ErrorMsg: fmt.Sprintf("Failed to marshal request: %v", err),
			}
		}

		err = json.Compact(dst, dataForSnap)
		if err != nil {
			return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
				ErrorMsg: err.Error(),
			}
		}
		dataForSnapStr = string(dst.Bytes())
		utils.SetSnapHeaders(localVarHeaderParams, a.GetConfig().APIKey, dataForSnapStr, localVarHTTPMethod, localVarPath, false, "")
		
	}
	req, err := a.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &exceptions.GenericOpenAPIError{
			RawBody:  localVarBody,
			ErrorMsg: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	// Return body data
	
	if localVarHTTPResponse.StatusCode >= 200 && localVarHTTPResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err == nil { 
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}
		return localVarReturnValue, localVarHTTPResponse, nil
}
type ApiDanaAccountInquiryRequest struct {
	ctx context.Context
	ApiService *DisbursementAPIService
	danaAccountInquiryRequest *DanaAccountInquiryRequest
}

func (r ApiDanaAccountInquiryRequest) DanaAccountInquiryRequest(danaAccountInquiryRequest DanaAccountInquiryRequest) ApiDanaAccountInquiryRequest {
	r.danaAccountInquiryRequest = &danaAccountInquiryRequest
	return r
}

func (r ApiDanaAccountInquiryRequest) Execute() (*DanaAccountInquiryResponse, *http.Response, error) {
	return r.ApiService.DanaAccountInquiryExecute(r)
}

/*
DanaAccountInquiry DANA Account Inquiry

This API is used for merchant to do account inquiry to DANA

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDanaAccountInquiryRequest
*/
func (a *DisbursementAPIService) DanaAccountInquiry(ctx context.Context) ApiDanaAccountInquiryRequest {
	return ApiDanaAccountInquiryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DanaAccountInquiryResponse
func (a *DisbursementAPIService) DanaAccountInquiryExecute(r ApiDanaAccountInquiryRequest) (*DanaAccountInquiryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []common.FormFile
		localVarReturnValue  *DanaAccountInquiryResponse
	)

	localBasePath, err := a.GetConfig().ServerURLWithContext(r.ctx, "DisbursementAPIService.DanaAccountInquiry")
	if err != nil {
		return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
			ErrorMsg: err.Error(),
		}
	}

	localVarPath := localBasePath + "/v1.0/emoney/account-inquiry.htm"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.danaAccountInquiryRequest == nil {
		return localVarReturnValue, nil, utils.ReportError("danaAccountInquiryRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := utils.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := utils.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.danaAccountInquiryRequest
	// Set API Key Authentication headers using centralized utility function
	if a.GetConfig() != nil && a.GetConfig().APIKey != nil {
		// Process request body for authentication if present
		var dataForSnapStr string
		dst := &bytes.Buffer{}
		dataForSnap, err := json.Marshal(localVarPostBody)
		if err != nil {
			return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
				ErrorMsg: fmt.Sprintf("Failed to marshal request: %v", err),
			}
		}

		err = json.Compact(dst, dataForSnap)
		if err != nil {
			return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
				ErrorMsg: err.Error(),
			}
		}
		dataForSnapStr = string(dst.Bytes())
		utils.SetSnapHeaders(localVarHeaderParams, a.GetConfig().APIKey, dataForSnapStr, localVarHTTPMethod, localVarPath, false, "")
		
	}
	req, err := a.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &exceptions.GenericOpenAPIError{
			RawBody:  localVarBody,
			ErrorMsg: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	// Return body data
	
	if localVarHTTPResponse.StatusCode >= 200 && localVarHTTPResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err == nil { 
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}
		return localVarReturnValue, localVarHTTPResponse, nil
}
type ApiTransferToBankRequest struct {
	ctx context.Context
	ApiService *DisbursementAPIService
	transferToBankRequest *TransferToBankRequest
}

func (r ApiTransferToBankRequest) TransferToBankRequest(transferToBankRequest TransferToBankRequest) ApiTransferToBankRequest {
	r.transferToBankRequest = &transferToBankRequest
	return r
}

func (r ApiTransferToBankRequest) Execute() (*TransferToBankResponse, *http.Response, error) {
	return r.ApiService.TransferToBankExecute(r)
}

/*
TransferToBank Transfer to Bank

This API is used for merchant to do transfer to Bank request via DANA

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTransferToBankRequest
*/
func (a *DisbursementAPIService) TransferToBank(ctx context.Context) ApiTransferToBankRequest {
	return ApiTransferToBankRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TransferToBankResponse
func (a *DisbursementAPIService) TransferToBankExecute(r ApiTransferToBankRequest) (*TransferToBankResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []common.FormFile
		localVarReturnValue  *TransferToBankResponse
	)

	localBasePath, err := a.GetConfig().ServerURLWithContext(r.ctx, "DisbursementAPIService.TransferToBank")
	if err != nil {
		return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
			ErrorMsg: err.Error(),
		}
	}

	localVarPath := localBasePath + "/v1.0/emoney/transfer-bank.htm"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.transferToBankRequest == nil {
		return localVarReturnValue, nil, utils.ReportError("transferToBankRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := utils.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := utils.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.transferToBankRequest
	// Set API Key Authentication headers using centralized utility function
	if a.GetConfig() != nil && a.GetConfig().APIKey != nil {
		// Process request body for authentication if present
		var dataForSnapStr string
		dst := &bytes.Buffer{}
		dataForSnap, err := json.Marshal(localVarPostBody)
		if err != nil {
			return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
				ErrorMsg: fmt.Sprintf("Failed to marshal request: %v", err),
			}
		}

		err = json.Compact(dst, dataForSnap)
		if err != nil {
			return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
				ErrorMsg: err.Error(),
			}
		}
		dataForSnapStr = string(dst.Bytes())
		utils.SetSnapHeaders(localVarHeaderParams, a.GetConfig().APIKey, dataForSnapStr, localVarHTTPMethod, localVarPath, false, "")
		
	}
	req, err := a.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &exceptions.GenericOpenAPIError{
			RawBody:  localVarBody,
			ErrorMsg: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	// Return body data
	
	if localVarHTTPResponse.StatusCode >= 200 && localVarHTTPResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err == nil { 
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}
		return localVarReturnValue, localVarHTTPResponse, nil
}
type ApiTransferToBankInquiryStatusRequest struct {
	ctx context.Context
	ApiService *DisbursementAPIService
	transferToBankInquiryStatusRequest *TransferToBankInquiryStatusRequest
}

func (r ApiTransferToBankInquiryStatusRequest) TransferToBankInquiryStatusRequest(transferToBankInquiryStatusRequest TransferToBankInquiryStatusRequest) ApiTransferToBankInquiryStatusRequest {
	r.transferToBankInquiryStatusRequest = &transferToBankInquiryStatusRequest
	return r
}

func (r ApiTransferToBankInquiryStatusRequest) Execute() (*TransferToBankInquiryStatusResponse, *http.Response, error) {
	return r.ApiService.TransferToBankInquiryStatusExecute(r)
}

/*
TransferToBankInquiryStatus Transfer to Bank Inquiry Status

This API is used for merchant to do inquiry status transfer to Bank transaction to DANA

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTransferToBankInquiryStatusRequest
*/
func (a *DisbursementAPIService) TransferToBankInquiryStatus(ctx context.Context) ApiTransferToBankInquiryStatusRequest {
	return ApiTransferToBankInquiryStatusRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TransferToBankInquiryStatusResponse
func (a *DisbursementAPIService) TransferToBankInquiryStatusExecute(r ApiTransferToBankInquiryStatusRequest) (*TransferToBankInquiryStatusResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []common.FormFile
		localVarReturnValue  *TransferToBankInquiryStatusResponse
	)

	localBasePath, err := a.GetConfig().ServerURLWithContext(r.ctx, "DisbursementAPIService.TransferToBankInquiryStatus")
	if err != nil {
		return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
			ErrorMsg: err.Error(),
		}
	}

	localVarPath := localBasePath + "/v1.0/emoney/transfer-bank-status.htm"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.transferToBankInquiryStatusRequest == nil {
		return localVarReturnValue, nil, utils.ReportError("transferToBankInquiryStatusRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := utils.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := utils.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.transferToBankInquiryStatusRequest
	// Set API Key Authentication headers using centralized utility function
	if a.GetConfig() != nil && a.GetConfig().APIKey != nil {
		// Process request body for authentication if present
		var dataForSnapStr string
		dst := &bytes.Buffer{}
		dataForSnap, err := json.Marshal(localVarPostBody)
		if err != nil {
			return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
				ErrorMsg: fmt.Sprintf("Failed to marshal request: %v", err),
			}
		}

		err = json.Compact(dst, dataForSnap)
		if err != nil {
			return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
				ErrorMsg: err.Error(),
			}
		}
		dataForSnapStr = string(dst.Bytes())
		utils.SetSnapHeaders(localVarHeaderParams, a.GetConfig().APIKey, dataForSnapStr, localVarHTTPMethod, localVarPath, false, "")
		
	}
	req, err := a.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &exceptions.GenericOpenAPIError{
			RawBody:  localVarBody,
			ErrorMsg: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	// Return body data
	
	if localVarHTTPResponse.StatusCode >= 200 && localVarHTTPResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err == nil { 
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}
		return localVarReturnValue, localVarHTTPResponse, nil
}
type ApiTransferToDanaRequest struct {
	ctx context.Context
	ApiService *DisbursementAPIService
	transferToDanaRequest *TransferToDanaRequest
}

func (r ApiTransferToDanaRequest) TransferToDanaRequest(transferToDanaRequest TransferToDanaRequest) ApiTransferToDanaRequest {
	r.transferToDanaRequest = &transferToDanaRequest
	return r
}

func (r ApiTransferToDanaRequest) Execute() (*TransferToDanaResponse, *http.Response, error) {
	return r.ApiService.TransferToDanaExecute(r)
}

/*
TransferToDana Transfer to DANA

This API is used for merchant to do top up request to DANA

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTransferToDanaRequest
*/
func (a *DisbursementAPIService) TransferToDana(ctx context.Context) ApiTransferToDanaRequest {
	return ApiTransferToDanaRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TransferToDanaResponse
func (a *DisbursementAPIService) TransferToDanaExecute(r ApiTransferToDanaRequest) (*TransferToDanaResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []common.FormFile
		localVarReturnValue  *TransferToDanaResponse
	)

	localBasePath, err := a.GetConfig().ServerURLWithContext(r.ctx, "DisbursementAPIService.TransferToDana")
	if err != nil {
		return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
			ErrorMsg: err.Error(),
		}
	}

	localVarPath := localBasePath + "/v1.0/emoney/topup.htm"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.transferToDanaRequest == nil {
		return localVarReturnValue, nil, utils.ReportError("transferToDanaRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := utils.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := utils.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.transferToDanaRequest
	// Set API Key Authentication headers using centralized utility function
	if a.GetConfig() != nil && a.GetConfig().APIKey != nil {
		// Process request body for authentication if present
		var dataForSnapStr string
		dst := &bytes.Buffer{}
		dataForSnap, err := json.Marshal(localVarPostBody)
		if err != nil {
			return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
				ErrorMsg: fmt.Sprintf("Failed to marshal request: %v", err),
			}
		}

		err = json.Compact(dst, dataForSnap)
		if err != nil {
			return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
				ErrorMsg: err.Error(),
			}
		}
		dataForSnapStr = string(dst.Bytes())
		utils.SetSnapHeaders(localVarHeaderParams, a.GetConfig().APIKey, dataForSnapStr, localVarHTTPMethod, localVarPath, false, "")
		
	}
	req, err := a.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &exceptions.GenericOpenAPIError{
			RawBody:  localVarBody,
			ErrorMsg: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	// Return body data
	
	if localVarHTTPResponse.StatusCode >= 200 && localVarHTTPResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err == nil { 
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}
		return localVarReturnValue, localVarHTTPResponse, nil
}
type ApiTransferToDanaInquiryStatusRequest struct {
	ctx context.Context
	ApiService *DisbursementAPIService
	transferToDanaInquiryStatusRequest *TransferToDanaInquiryStatusRequest
}

func (r ApiTransferToDanaInquiryStatusRequest) TransferToDanaInquiryStatusRequest(transferToDanaInquiryStatusRequest TransferToDanaInquiryStatusRequest) ApiTransferToDanaInquiryStatusRequest {
	r.transferToDanaInquiryStatusRequest = &transferToDanaInquiryStatusRequest
	return r
}

func (r ApiTransferToDanaInquiryStatusRequest) Execute() (*TransferToDanaInquiryStatusResponse, *http.Response, error) {
	return r.ApiService.TransferToDanaInquiryStatusExecute(r)
}

/*
TransferToDanaInquiryStatus Transfer to DANA Inquiry Status

This API is used for merchant to do inquiry status top up transaction to DANA

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTransferToDanaInquiryStatusRequest
*/
func (a *DisbursementAPIService) TransferToDanaInquiryStatus(ctx context.Context) ApiTransferToDanaInquiryStatusRequest {
	return ApiTransferToDanaInquiryStatusRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TransferToDanaInquiryStatusResponse
func (a *DisbursementAPIService) TransferToDanaInquiryStatusExecute(r ApiTransferToDanaInquiryStatusRequest) (*TransferToDanaInquiryStatusResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []common.FormFile
		localVarReturnValue  *TransferToDanaInquiryStatusResponse
	)

	localBasePath, err := a.GetConfig().ServerURLWithContext(r.ctx, "DisbursementAPIService.TransferToDanaInquiryStatus")
	if err != nil {
		return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
			ErrorMsg: err.Error(),
		}
	}

	localVarPath := localBasePath + "/v1.0/emoney/topup-status.htm"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.transferToDanaInquiryStatusRequest == nil {
		return localVarReturnValue, nil, utils.ReportError("transferToDanaInquiryStatusRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := utils.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := utils.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.transferToDanaInquiryStatusRequest
	// Set API Key Authentication headers using centralized utility function
	if a.GetConfig() != nil && a.GetConfig().APIKey != nil {
		// Process request body for authentication if present
		var dataForSnapStr string
		dst := &bytes.Buffer{}
		dataForSnap, err := json.Marshal(localVarPostBody)
		if err != nil {
			return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
				ErrorMsg: fmt.Sprintf("Failed to marshal request: %v", err),
			}
		}

		err = json.Compact(dst, dataForSnap)
		if err != nil {
			return localVarReturnValue, nil, &exceptions.GenericOpenAPIError{
				ErrorMsg: err.Error(),
			}
		}
		dataForSnapStr = string(dst.Bytes())
		utils.SetSnapHeaders(localVarHeaderParams, a.GetConfig().APIKey, dataForSnapStr, localVarHTTPMethod, localVarPath, false, "")
		
	}
	req, err := a.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &exceptions.GenericOpenAPIError{
			RawBody:  localVarBody,
			ErrorMsg: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	// Return body data
	
	if localVarHTTPResponse.StatusCode >= 200 && localVarHTTPResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err == nil { 
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}
		return localVarReturnValue, localVarHTTPResponse, nil
}
